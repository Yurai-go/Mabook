<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Book Recommendations</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    animation: {
                        'spin': 'spin 1s linear infinite',
                    }
                }
            }
        }
    </script>
    <style>
        .search-input {
            resize: none;
        }
        .search-input::-webkit-scrollbar {
            width: 4px;
        }
        .search-input::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        .search-input::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 2px;
        }
    </style>
</head>
<body class="font-sans bg-black min-h-screen p-5">
    <div class="max-w-4xl mx-auto">
        <div class="text-center text-white mb-10">
            <h1 class="text-4xl mb-2.5 drop-shadow-lg">ðŸ“š AI Book Recommendations</h1>
            <p class="text-lg opacity-90">Get personalized book recommendations powered by AI</p>
        </div>

        <div class="mb-8">
            <div class="flex items-center w-full bg-white border border-neutral-300 rounded-2xl p-2 transition-all duration-300 focus-within:border-black min-h-[60px]">
                <textarea 
                    class="search-input w-full flex-grow bg-transparent text-black placeholder-neutral-500 pl-4 text-base leading-relaxed focus:outline-none max-h-[250px] overflow-y-auto" 
                    id="promptInput" 
                    placeholder="Ask me anything about books you'd like to read..." 
                    rows="1">
                </textarea>
                <button 
                    class="send-btn flex-shrink-0 w-10 h-10 bg-black text-white rounded-full flex items-center justify-center transition-all duration-300 hover:bg-neutral-800 disabled:bg-neutral-200 disabled:text-neutral-500 disabled:cursor-not-allowed mx-1" 
                    id="sendBtn" disabled>
                    <svg viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                </button>
            </div>
        </div>

        <div class="loading hidden text-center text-white text-lg my-5" id="loading">
            <div class="border-4 border-white border-opacity-30 border-t-white rounded-full w-8 h-8 animate-spin mx-auto mb-2.5"></div>
            <p>AI is analyzing your request and finding the best book recommendations...</p>
        </div>

        <div class="results-container hidden" id="resultsContainer">
            </div>
    </div>

    <script>
        /**
         * Manages the entire book recommendation application.
         */
        class BookRecommendationSystem {
            constructor() {
                // For optimal performance, cache frequently accessed DOM elements.
                this.elements = {
                    promptInput: document.getElementById('promptInput'),
                    sendBtn: document.getElementById('sendBtn'),
                    loading: document.getElementById('loading'),
                    resultsContainer: document.getElementById('resultsContainer'),
                };

                this.debugMode = true; // Enable debug logging
                
                // Static constants for better maintainability.
                this.AVAILABLE_GENRES = [
                    "Habits", "Finance", "Leadership", "Mental health", "Motivational", 
                    "Physical Health", "Time Management", "Communication", "Self-Discovery", 
                    "Decision making", "Creativity", "Cognitive intelligence", "Behaviour", 
                    "Emotional Intelligence", "Innovation", "Philosophy", "Entrepreneurship"
                ];
                this.API_BASE_URL = window.location.origin;
                
                this.initializeEventListeners();
                this.checkServerHealth();
            }

            /**
             * Sets up all necessary event listeners for the application.
             */
            initializeEventListeners() {
                this.elements.sendBtn.addEventListener('click', () => this.handleSearch());
                
                this.elements.promptInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.handleSearch();
                    }
                });

                // Auto-resize textarea and manage send button state.
                this.elements.promptInput.addEventListener('input', () => {
                    const input = this.elements.promptInput;
                    input.style.height = 'auto'; // Reset height to calculate scrollHeight correctly.
                    input.style.height = `${Math.min(input.scrollHeight, 250)}px`;
                    this.elements.sendBtn.disabled = input.value.trim() === '';
                });
            }

            /**
             * Orchestrates the entire search and recommendation process.
             */
            async handleSearch() {
                const prompt = this.elements.promptInput.value.trim();
                
                if (!prompt) {
                    this.showError('Please enter a prompt to get recommendations.');
                    return;
                }

                this.showLoading(true);
                this.clearResults();

                try {
                    this.showDebugInfo(`Step 1: Analyzing prompt for genres...`);
                    const genrePrompt = this.generateAIPrompt('genreAnalysis', prompt, this.AVAILABLE_GENRES.join(', '));
                    const genreResult = await this._callBackendAPI('/ai/analyze', { prompt: genrePrompt });
                    const genres = genreResult.genres || [];
                    this.log('Determined genres:', genres);
                    this.showDebugInfo(`Found genres: ${genres.join(', ')}`);

                    if (genres.length === 0) throw new Error('No relevant genres found for your query.');

                    this.showDebugInfo(`Step 2: Fetching books from database...`);
                    const books = await this._callBackendAPI('/books/search', { genres });
                    this.log('Found books:', books.length);
                    this.showDebugInfo(`Found ${books.length} books in database`);

                    if (books.length === 0) throw new Error('No books found for the determined genres.');

                    this.showDebugInfo(`Step 3: Extracting and analyzing individual highlights...`);
                    const allHighlights = this._extractAllHighlights(books);
                    this.log('Total extracted highlights:', allHighlights.length);
                    this.showDebugInfo(`Extracted ${allHighlights.length} individual highlights`);

                    if (allHighlights.length === 0) throw new Error('No valid highlights found in the books.');

                    this.showDebugInfo(`Step 4: AI analyzing each highlight for relevance...`);
                    const highlightData = allHighlights.map(h => `ID: ${h.id} | Book: "${h.bookTitle}" | Highlight: "${h.text}"`).join('\n');
                    const rankingPrompt = this.generateAIPrompt('highlightRanking', prompt, null, highlightData, allHighlights.length);
                    const rankingResult = await this._callBackendAPI('/ai/analyze', { prompt: rankingPrompt });
                    const selectedHighlightIds = (rankingResult.recommendations || []).map(rec => rec.id);
                    this.log('AI selected highlight IDs:', selectedHighlightIds);

                    const recommendations = this._buildRecommendations(selectedHighlightIds, allHighlights);
                    this.log('Final recommendations count:', recommendations.length);

                    if (recommendations.length === 0) throw new Error('No highlights match your query well enough.');
                    
                    this.showDebugInfo(`Displaying ${recommendations.length} most relevant highlights`);
                    this.displayRecommendations(recommendations);

                } catch (error) {
                    this.log('Error in handleSearch:', error);
                    this.showError(error.message || 'An error occurred while getting recommendations.');
                } finally {
                    this.showLoading(false);
                }
            }

            /**
             * Renders the final recommendations to the DOM.
             * @param {Array<object>} recommendations - An array of recommendation objects.
             */
            displayRecommendations(recommendations) {
                if (!recommendations || recommendations.length === 0) {
                    this.showError('No relevant highlights found that match your query.');
                    return;
                }

                const recommendationsHTML = recommendations
                    .map((rec, index) => this._createRecommendationHTML(rec, index))
                    .join('');

                this.elements.resultsContainer.innerHTML = recommendationsHTML;
                this.elements.resultsContainer.style.display = 'block';
                
                setTimeout(() => {
                    document.querySelectorAll('.debug-info').forEach(info => info.remove());
                }, 500);
            }

            /**
             * Generates the HTML string for a single recommendation card.
             * @private
             * @param {object} rec - The recommendation object.
             * @param {number} index - The index for the "Best Match" badge.
             * @returns {string} The HTML string for the card.
             */
            _createRecommendationHTML(rec, index) {
                const { title, author, highlight } = rec;
                return `
                    <div class="bg-white rounded-2xl p-6 mb-5 shadow-lg border-l-4 border-black transition-transform duration-300 hover:-translate-y-1 hover:shadow-xl relative">
                        <div class="absolute top-4 right-4 bg-black text-white text-xs px-2 py-1 rounded-full font-semibold">
                            #${index + 1} Best Match
                        </div>
                        <div class="text-base leading-relaxed text-neutral-800 bg-neutral-100 p-4 rounded-lg border-l-4 border-neutral-400 italic mb-4 pr-20">"${this.escapeHtml(highlight)}"</div>
                        <div class="text-xl font-bold text-black mb-2">${this.escapeHtml(title)}</div>
                        <div class="text-base text-neutral-600 italic">by ${this.escapeHtml(author)}</div>
                    </div>
                `;
            }

            /**
             * Toggles the loading indicator and disables the search button.
             * @param {boolean} show - Whether to show or hide the loading state.
             */
            showLoading(show) {
                this.elements.loading.style.display = show ? 'block' : 'none';
                this.elements.sendBtn.disabled = show;
            }

            /**
             * Clears all results and error messages from the container.
             */
            clearResults() {
                this.elements.resultsContainer.style.display = 'none';
                this.elements.resultsContainer.innerHTML = '';
                
                document.querySelectorAll('.error-message, .debug-info').forEach(el => el.remove());
            }

            /**
             * Displays a formatted error message to the user.
             * @param {string} message - The error message to display.
             */
            showError(message) {
                this.clearResults();
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message bg-neutral-800 border border-neutral-600 text-white p-4 rounded-lg my-5 text-center';
                errorDiv.textContent = message;
                this.elements.resultsContainer.parentNode.insertBefore(errorDiv, this.elements.resultsContainer);
                this.log('Error displayed:', message);
            }

            // --- HELPER AND UTILITY FUNCTIONS ---

            _extractAllHighlights(books) {
                const allHighlights = [];
                books.forEach((book, bookIndex) => {
                    const highlights = this._parseHighlights(book.highlights);
                    highlights.forEach((highlight, highlightIndex) => {
                        allHighlights.push({
                            id: `highlight_${bookIndex}_${highlightIndex}`,
                            text: highlight,
                            bookTitle: book.title,
                            bookAuthor: book.author
                        });
                    });
                });
                return allHighlights;
            }
            
            _buildRecommendations(selectedIds, allHighlights) {
                const recommendations = [];
                for (const id of selectedIds) {
                    const highlight = allHighlights.find(h => h.id === id);
                    if (highlight) {
                        recommendations.push({
                            title: highlight.bookTitle,
                            author: highlight.bookAuthor,
                            highlight: highlight.text
                        });
                    }
                }
                return recommendations;
            }

            /**
             * A flexible helper for making API calls to the backend.
             * @private
             * @param {string} endpoint - The API endpoint (e.g., '/health').
             * @param {object} data - The JSON data to send in the body for POST/PUT requests.
             * @param {string} [method='POST'] - The HTTP method to use.
             * @returns {Promise<object>} The JSON response from the server.
             */
            async _callBackendAPI(endpoint, data, method = 'POST') {
                try {
                    this.log(`Calling backend API: ${endpoint}`, { data, method });
                    
                    const config = {
                        method: method,
                        headers: { 'Content-Type': 'application/json' },
                    };

                    if (method !== 'GET') {
                        config.body = JSON.stringify(data);
                    }

                    const response = await fetch(`${this.API_BASE_URL}/api${endpoint}`, config);

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || `API error (${response.status})`);
                    }
                    return await response.json();
                } catch (error) {
                    this.log('Backend API call failed:', error);
                    throw new Error(`Backend API call failed: ${error.message}`);
                }
            }
            
            async checkServerHealth() {
                try {
                    // Call the health check endpoint using the GET method.
                    const health = await this._callBackendAPI('/health', null, 'GET');
                    this.log('Server health check:', health);
                    if (!health.env.hasGroqKey || !health.env.hasSupabaseUrl || !health.env.hasSupabaseKey) {
                        this.showError('Server configuration incomplete.');
                    }
                } catch (error) {
                    this.showError('Cannot connect to backend server.');
                }
            }
            
            _parseHighlights(highlightsText) {
                if (!highlightsText || typeof highlightsText !== 'string') return [];
                return highlightsText.split('"').map(h => h.trim()).filter(Boolean);
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            log(message, data = null) {
                if (this.debugMode) console.log(`[DEBUG] ${message}`, data || '');
            }

            showDebugInfo(message) {
                if (!this.debugMode) return;
                const debugDiv = document.createElement('div');
                debugDiv.className = 'debug-info bg-white bg-opacity-10 border border-white border-opacity-30 text-white p-2.5 rounded-lg my-2.5 text-xs font-mono';
                debugDiv.textContent = message;
                this.elements.resultsContainer.parentNode.insertBefore(debugDiv, this.elements.resultsContainer);
            }

            generateAIPrompt(taskType, userPrompt, availableGenres = null, highlightData = null, totalCount = 0) {
                const prompts = {
                    genreAnalysis: {
                        role: "You are a specialized AI assistant with expert knowledge of book genres and user intent analysis.",
                        context: `Available genres: ${availableGenres}`,
                        task: `Analyze the user's query and determine which book genres would be most relevant.`,
                        process: `
1. Carefully read the user's query to understand their needs, interests, or preferences.
2. Scan the available genres for the best matches based on the query content.
3. Prioritize genres where the benefits directly address the user's query.
4. Select minimum 1 and maximum 3 genres that are most relevant.
5. If the query is vague or unclear, choose the most general applicable genres.`,
                        outputFormat: `
- Your response MUST be a valid JSON object.
- The JSON object must have a single key: "genres".
- The value of "genres" must be an array of strings.
- Each string must be the exact "Name" of a recommended genre.
- Select minimum 1 and maximum 3 genres from the available list.
- Example: {"genres": ["Mental health", "Habits", "Leadership"]}
- If no matches: {"genres": []}
- Do NOT include any other text, explanations, or markdown formatting.`,
                        content: `User query: "${userPrompt}"\n\nSelected genres:`
                    },
                    highlightRanking: {
                        role: "You are an expert content analyst specializing in matching book insights to user queries with surgical precision.",
                        context: `You have ${totalCount} individual book highlights from multiple books. Your task is to find the most relevant highlights that directly answer or address the user's specific query.`,
                        task: `Select the TOP 5 most relevant highlights that best answer the user's query. Multiple highlights from the same book are allowed if they're all highly relevant, but never select identical highlights.`,
                        process: `
1. Analyze the user's query to identify their specific need, problem, or area of interest.
2. Evaluate each highlight for direct relevance to the query - how well does it answer or address what the user is asking?
3. Score each highlight: HIGH (directly answers query), MEDIUM (related/helpful), LOW (tangentially related).
4. Select only HIGH and strong MEDIUM scoring highlights.
5. Rank selected highlights by relevance score (best matches first).
6. It's acceptable to select multiple highlights from the same book if they're all highly relevant.
7. Never select duplicate/identical highlights.
8. Maximum 5 highlights total, but fewer is acceptable if only a few are truly relevant.`,
                        outputFormat: `
- Your response MUST be a valid JSON object.
- The JSON object must have a single key: "recommendations".
- The value must be an array of objects, each with "id" field.
- Each "id" must match exactly one of the highlight IDs provided.
- Order by relevance (best match first).
- Maximum 5 recommendations, minimum 1.
- Example: {"recommendations": [{"id": "highlight_3"}, {"id": "highlight_7"}, {"id": "highlight_1"}]}
- Do NOT include any other text, explanations, or markdown formatting.`,
                        content: `Available highlights:\n${highlightData}\n\nUser query: "${userPrompt}"\n\nBest matching highlights (ranked by relevance):`
                    }
                };
                const selectedPrompt = prompts[taskType];
                if (!selectedPrompt) throw new Error(`Unknown task type: ${taskType}`);
                return `# ROLE\n${selectedPrompt.role}\n\n# CONTEXT\n${selectedPrompt.context}\n\n# TASK\n${selectedPrompt.task}\n\n# PROCESS\n${selectedPrompt.process}\n\n# OUTPUT FORMAT\n${selectedPrompt.outputFormat}\n\n${selectedPrompt.content}`;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log('Initializing Book Recommendation System...');
            new BookRecommendationSystem();
        });
    </script>
</body>
</html>